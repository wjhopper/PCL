---
title: "PCR & Roediger and Karpicke 2006 data"
author: "Will Hopper "
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    fig_caption: yes
    toc: true
    toc_depth: 4
    css: custom.css
params:
  inpar: TRUE
  model: RK_PCR
  routine: minimize
  pars: !r c("ER","LR","Ta","TR","Tmin","Tmax","lambda")
  fixed: !r c(FR=0,theta=.5,nFeat=100,nSim=1000,nList=15,Time=90)    
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup,echo=FALSE,message=FALSE,warning=FALSE}
library(optimx)
library(dplyr)
library(ggplot2)
library(reshape2)
library(knitr)
library(xtable)
library(whoppeR)
library(PCR)
opts_chunk$set(echo = FALSE,fig.width=11,fig.height=7,cache=FALSE, 
               warning=F, message=FALSE, fig.align='center')
```

```{r rawData}
raw <- data.frame(
  group = c("S","T","S","T","S","T","S","T"), 
  acc = c(NA,.7,.81,.75,.54,.68,.42,.56),
  timepoint = c(1,1,2,2,3,3,4,4),
  n = c(NA,30,30,30,30,30,30,30))
```

```{r functions}
RK_PCR <- function(ER=.587, LR=.0936, TR =.1, F1=.133, F2=.06, Tmin=15.7, Tmax=60, 
                   lambda=.5, Ta=49.5, nFeat=100, nSim=1000, nList=30,
                   Time=420, summarised = TRUE, bounds) {
  set.seed(456)
  mxn <-  nSim*nList #dimensions precalculation

  # we want to sample from a beta distribution with the same
  # mean and sd as binomial(N = nFeat,p=ER) distribution.
  # The problem is that the binomial is [0,nFeat], and the equations we
  # to solve for beta distributions alpha and beta from mean and sd
  # are for beta bounded between zero and 1 aka the 2 parameter beta.
  # So we need to divide the mean and varianace of the binomial by nFeat
  # and nFeat^2. Then we can use our equations, and multiply by nFeat after sampling

  binomVAR <- nFeat*ER*(1-ER)
  binomM <- nFeat*ER
  beta_pars = betaABfromMeanSD(mean = binomM/nFeat,
                               sd = sqrt(binomVAR/nFeat^2))
  
  # Initial encoding
  mem <- matrix(rbeta(mxn, beta_pars$a, beta_pars$b),
                nrow=nSim,ncol=nList) * nFeat
  thresh <- matrix(rbeta(mxn, Ta,  Ta),
                   nrow=nSim,ncol=nList) * nFeat

  # practice test performance
  prac <- freeRecall(mem,thresh, Tmin = Tmin, Tmax = Tmax,
                     Time = Time, lambda=lambda)

  # study practice boost
  restudyStrengths <- study_beta(mem=mem, nFeatures=nFeat,
                            LR = LR)
  # study practice @ 5 mins 
  restudy5 <- freeRecall(restudyStrengths, thresh, Tmin = Tmin, Tmax = Tmax,
                      Time = Time, lambda=lambda)

  # test practice boost
  testStrengths <- test_beta(mem=mem,  nFeatures=nFeat,
                        thresh = thresh, acc = prac$Acc, LR = LR,
                        TR = TR)
  
  # test practice @ 5 Minutes  
  tested5 <- freeRecall(testStrengths$mem, testStrengths$thresh,
                     Tmin = Tmin, Tmax = Tmax,
                     Time = Time, lambda=lambda)

  # study practice, 1 day
  restudyStrengths  <- forget_beta(mem = restudyStrengths, FR = F1)
  restudy2d <- freeRecall(restudyStrengths, thresh, Tmin = Tmin, Tmax = Tmax,
                      Time = Time, lambda=lambda)

  # test practice, 1 day
  testStrengths$mem <- forget_beta(mem = testStrengths$mem, FR = F1)
  tested2d <- freeRecall(testStrengths$mem, testStrengths$thresh,
                     Tmin = Tmin, Tmax = Tmax,
                     Time = Time, lambda=lambda)

  # study practice, 7 days
  restudyStrengths  <- forget_beta(mem = restudyStrengths, FR = F2)
  restudy7d <- freeRecall(restudyStrengths, thresh, Tmin = Tmin, Tmax = Tmax,
                      Time = Time, lambda=lambda)

  # test practice, 7 days
  testStrengths$mem <- forget_beta(mem = testStrengths$mem, FR = F2)
  tested7d <- freeRecall(testStrengths$mem, testStrengths$thresh,
                     Tmin = Tmin, Tmax = Tmax,
                     Time = Time, lambda=lambda)  

  # Putting the output together
  order <- rbind(prac$order,restudy5$order,tested5$order,
                 restudy2d$order,tested2d$order,
                 restudy7d$order,tested7d$order)
  RT <- rbind(prac$RT,restudy5$RT,tested5$RT,
              restudy2d$RT,tested2d$RT,
              restudy7d$RT,tested7d$RT)
  RTcor <- rbind(prac$RTcor,restudy5$RTcor,tested5$RTcor,
                 restudy2d$RTcor,tested2d$RTcor,
                 restudy7d$RTcor,tested7d$RTcor)
  rec <- rbind(prac$recoverable,restudy5$recoverable,tested5$recoverable,
               restudy2d$recoverable,tested2d$recoverable,
               restudy7d$recoverable,tested7d$recoverable)
  acc <- rbind(prac$Acc,restudy5$Acc,tested5$Acc,
               restudy2d$Acc,tested2d$Acc,
               restudy7d$Acc,tested7d$Acc)

  # Sorting the output
  for (x in 1:(nrow(order))) {
    RT[x,] <- RT[x,order[x,]]
    RTcor[x,] <- RTcor[x,order[x,]]
    rec[x,] <- rec[x,order[x,]]
    acc[x,] <- acc[x,order[x,]]
  }

  # Reshaping the output
  acc <-melt(acc, varnames=c("class","memOrder"),value.name = "acc")
  RT <- melt(RT, varnames=c("class","memOrder"),value.name = "memRT")
  RTcor <- melt(RTcor, varnames=c("class","memOrder"),value.name = "obsRT")
  rec <- melt(rec, varnames=c("class","memOrder"),value.name = "rec")

  preds <- Reduce(function(x,y) left_join(x,y, by = c("class", "memOrder")),
                  x=list(acc,RT,RTcor,rec)) %>%
    mutate(class = rep(rep(c("T","S","T","S","T","S","T"),
                            each = nSim),
                        times = nList),
           sim  = rep(1:nSim, times = nrow(.)/nSim),
           timepoint = rep(rep(c(1,2,2,3,3,4,4), each = nSim),
                        times = nList),
           unrec = !rec & !acc,
           timeout = !acc & rec) %>%
    group_by(class,sim,acc) %>%
    mutate(obsOrder = 1:n(),
           obsOrder = replace(obsOrder, acc==FALSE, NA)) %>%
    select(-rec) %>% 
    ungroup() %>% 
    arrange(timepoint,class,memOrder,sim)

  # Check summarise switch
  if (summarised) {
    preds <- preds %>%
      group_by(class,timepoint) %>% 
      summarise(pred_acc = mean(acc))
  }
  return(preds)
}


g2 <- function(obs, pred, N) {
  Lc <- obs*(log(pred)) + ((1-obs)*log(1-pred))
  Lu <- obs*(log(obs)) + ((1-obs)*log(1-obs))
  err <- -sum(2*N*(Lc-Lu))
  return(err)
}

objFun <- function(free, fixed, model = params$model, obs  = raw, 
                   errorFun = g2, bounds = paramBounds) {
  
  if (!paramBounds(c(free,fixed)) | anyNA(c(free,fixed))) {
    return(1000000)
  }
  
  p <- c(as.list(c(free,fixed)), summarized=TRUE)
  preds <- do.call(model,p)
  data <- left_join(data,preds, by = c("group","timepoint"))
  data <- data[!is.na(data$N),]
  err <- errorFun(data$obs, data$pred_acc, data$n)
  return(err)
}

routine <- function(mode) {
  if (identical(mode,"minimize")) {
    fun <- function(model, fun = objFun) {
      fit <- optimx(par = model$free[[j]],
                    fn = fun,
                    method="Nelder-Mead",
                    itnmax=1000,
                    control = list(maxit=1000,kkt=FALSE,
                                   parscale = c(1,1,200,1,1,100,1)),
                    fcn = model$obj, # passed to erf
                    fixed = model$fixed, # passed to erf
                    obs = model$data[model$data$subject == j,])      # passed to erf
      fit$subject = j
      return(fit)  
    }
  } else {
    fun <- function(model, fun = objFun) {
      err <- fun(free = model$free[[j]], fixed = model$fixed, 
                 obs = model$data[model$data$subject == j,])
      fit <- structure(data.frame(t(c(model$free[[j]], value = err,subject=j))),
                       details = NULL, maximize = NULL,
                       npar = length(model$free[[j]]), follow.on=NULL,
                       class = c("optimx", "data.frame"))
      return(fit)
    }
  }
}

paramBounds <- function(p) {

  probability_params <- c("ER","LR","TR","FR")
  strict_positive_params <- c("Tmin","Tmax","lambda")
  above_one_params <- c("Ta","Tb")

  prob_check <- any(p[names(p) %in% probability_params] <= 0, na.rm = TRUE) ||
                any(p[names(p) %in% probability_params] >= 1, na.rm = TRUE)
  strict_pos_check <- any(p[names(p) %in% strict_positive_params] <= 0, na.rm = TRUE)
  above_one_check <- any(p[names(p) %in% above_one_params] <= 1, na.rm = TRUE)
  
  if (any(prob_check, strict_pos_check, above_one_check)) {
    return(FALSE)
  } else {
    return(TRUE)
  }
}

```
